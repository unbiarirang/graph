<!DOCTYPE html>
<meta charset="utf-8">
<title>Graph</title>
<link rel="stylesheet" type="text/css" href="style.css">
<script src="http://d3js.org/d3.v3.min.js"></script>

<body>
	<div id="graph">
		<form>
			Gravity <input id="gravitySlider" type="range" onchange="updateForce(); changeGravity()" min ="0" max="1" step =".01"  value=".1" />
			<input type="text" id="gravityInput" value=".1" />
		</form>
		<div id="definitionbox" height="1px">
		</div>
	</div>

	<div id="lesson">
		<div id="lessontitle">
		<h1>Graph</h1>
		<h2>Choi eun bi Lee sang hyeok</h2>
		</div>

		<div>
			<ol>
				<li>Layouts</li>
				<li><input type="button" value="Force-Directed" onclick='updateForce(); updateText("forcealgo")'><input type="button" value="Plot" onclick='plotLayout(); updateText("plotlayout")'></li>
				<li>Features</li>
				<li><input type="button" value="Pathfinding" onclick='selectPath(); updateText("pathfinding")'></li>
				<li><input type="button" value="Centrality" onclick='calculateCentrality(); updateText("centrality")' />
			</ol>
		</div>

		<div id="text">
		</div>
	</div>
</body>

<script>
var currentSizing = "nothing";
var currentEdge = "fixed";
var sourceNode = "";
var width = 500,
    height = 600;
var fill = d3.scale.category20();

// set the initial state
randomGraph(50, 0.025);
updateText("introduction");

function updateText(lessonType) {
	switch(lessonType) {        
		case "introduction":
		d3.select("#text").html("<h2>Introduction</h2><p>Networks and network analysis has grown more prominent in both humanities scholarship and public discourse. In this context, networks--also known as graphs or node-link diagrams--are \"a set of vertices (also called points or nodes) which represent the entities of research interest, and a set of lines (or ties) between these vertices which represent their relationships.\" [1]</p><p>This interactive application is designed to provide an overview of various network analysis principles used for analysis and representation. It also provides a few examples of untraditional networks used in digital humanities scholarship. Finally, along with the various methods described interactively here are links to related scholarship.</p><p>Each network type is listed in the Models section, and can be paired with an analysis or representation method by simply clicking on a network type to load a new network, and then clicking on an analysis or visualization method.</p><p>Networks are represented using traditional force-directed techniques or by plotting along the xy axis based on numerical attributes of the nodes (longitude and latitude in the case of nodes that represent geographic entities). For the force directed layout, you can adjust the various force principles to see how this affects the representation of the network you're working with.</p><p>This implementation will likely remain a work-in-progress for some time, and if you notice any flaws or discrepencies, or have a suggestion, please contact <a href='mailto:emeeks@stanford.edu'>Elijah Meeks</a>.</p>");
		break;
		case "pathfinding":
		d3.select("#text").html("<h2>Shortest Path</h2><p>Finding the shortest path between two nodes in a network.<br>We used Dijkstra's algorithm to accomplish pathfiding.</p>");
		break;
		case "centrality":
		d3.select("#text").html("<h2>Centrality</h2><br><h3>1. Closeness</h3><p>The average shortest path cost to all the nodes in the network.</p><input type='button' onclick='sizeByStats(\"Closeness\")' value='Closeness'/><br><br><h3>2. Betweenness</h3><p>The number of times a node is crossed for every shortest path in the network.</p><input type='button' onclick='sizeByStats(\"Betweenness\")' value='Betweenness Centrality' />");
		break;
		case "forcealgo":
		d3.select("#text").html("<h2>Force-Directed Layout</h2><p>A popular method for laying out networks is to assign repulsive and attractive forces to nodes and links so that the emergent behavior of the competing forces produces a network that is more legible than manually or hierarchically placing the nodes. These competing forces are typcially a repulsive force exerted by nodes (which can be based on a numerical attribute of the node or a fixed value), an attractive force exerted by shared links between nodes (which can be based on the strength of the length, typically known as \"weight\" or fixed) and a canvas gravity that draws nodes toward the center of the screen and prevents them from being pushed beyond the view of the user.</p><p>Force-directed layouts do not typically assign any value to a node being placed along the x- or y-axis beyond the confluence of forces acting upon it from nearby nodes and links. As a result, even a very stable and readable force-directed layout can be mirrored or rotated without otherwise changing. This has had the effect upon scholars of assuming that there was something wrong with a force-directed layout that placed a node on the 'top' or 'left' in one layout but on the 'bottom' or 'right' in another. Such behavior is part of the force-directed layout unless specifically designed otherwise.</p>");
		break;
	}
}

function initializeGraph(newGraph) {
	newNodes = [];
	newLinks = [];
	//We need a hash to fit the link structure of D3's force-directed layout
	nodeHash = {};
	for ( x = 0; x < newGraph.nodes.length; x++ ) {
		newNodes.push(newGraph.nodes[x]);
		nodeHash[String(newGraph.nodes[x].id)] = x;
	}
	for ( x = 0; x < newGraph.links.length; x++ )
		newLinks.push({id: x, source: newGraph.nodes[nodeHash[newGraph.links[x].source]], target: newGraph.nodes[nodeHash[newGraph.links[x].target]], "cost": newGraph.links[x].cost, "weight": newGraph.links[x].invcost });

	force = d3.layout.force()
		.size([width, height])
		.nodes(newNodes) // initialize with a single node
		.links(newLinks)
		.linkDistance(60)
		.charge(-60)
		.on("tick", tick);
	var svg = d3.select("#graph").append("svg")
		.attr("width", width)
		.attr("height", height)
		.attr("id", "networkViz");
	svg.append("rect")
		.attr("width", width)
		.attr("height", height)
		.attr("id","backgroundRect")
		.on("mousemove", mousemove);
	nodes = force.nodes();
	links = force.links();
	node = svg.selectAll(".node");
	link = svg.selectAll(".link");
	arrowhead = svg.selectAll(".link");
	cursor = svg.append("circle")
		.attr("transform", "translate(-100,-100)")
		.attr("class", "cursor")
		.attr("r", 1)
		.style("opacity", 0);
	restart();
}

function mousemove() {
  	cursor.attr("transform", "translate(" + d3.mouse(this) + ")");
}

function mousedown() {
  var point = d3.mouse(this),
      node = {id: nodes.length, label: "Node" + nodes.length, lat: .5, long: .25, weight: 1, x: point[0], y: point[1]},
      n = nodes.push(node);
  // add links to any nearby nodes
	nodes.forEach(function(target) {
		var x = target.x - node.x,
			y = target.y - node.y;
		if (Math.sqrt(x * x + y * y) < 30)
			links.push({id: links.length, source: node, target: target, cost: .5});
	});
	restart();
}

function tick() {
  	link.attr("x1", function(d) { return d.source.x; })
		.attr("y1", function(d) { return d.source.y; })
		.attr("x2", function(d) { return d.target.x; })
		.attr("y2", function(d) { return d.target.y; });
	node.attr("transform",function(d) {return "translate(" + d.x + "," + d.y + ")"}) 
    arrowhead.attr("cx", function(d) {return ((d.target.x * .9) + (d.source.x * .1))}).attr("cy", function(d) {return ((d.target.y * .9) + (d.source.y * .1))})
}

function changeGravity() {
    d3.select("#definitionbox").html("Canvas gravity draws all nodes toward the center of the canvas, preventing them from flying out of view.");
}

function highlightNodes() {
	d3.selectAll("circle.node").transition().duration(300).style("stroke-width", 5);
	d3.selectAll("circle.node").transition().delay(300).duration(300).style("stroke-width", 0);
	if (document.getElementById('nodeCheckbox').checked == true) {
		document.getElementById("repulsionSlider").disabled=true;
		d3.select("#definitionbox").html("Nodes exert a repulsion on other nodes based on their degree centrality.");
	}
	else {
		document.getElementById("repulsionSlider").disabled=false;
		d3.select("#definitionbox").html("Nodes exert a fixed value of repulsion set with the slider.");
	}
}

function highlightEdges() {
	d3.selectAll("line.link").transition().duration(300).style("stroke", "black");
	d3.selectAll("line.link").transition().delay(300).duration(300).style("stroke", "#999999")
	if (document.getElementById('edgeCheckbox').checked == true) {
		document.getElementById("attractionSlider").disabled=true;
		d3.select("#definitionbox").html("Nodes attract connected nodes based on the strength of the shared link.");
	}
	else {
		document.getElementById("attractionSlider").disabled=false;
		d3.select("#definitionbox").html("Nodes attract connected nodes based on the fixed value set on the slider.");
	}
}

function restart() {
	link = link.data(links);
	arrowhead = arrowhead.data(links);
	node = node.data(nodes);
  	nodeg = node.enter().insert("g", ".cursor")
		.attr("class", "node")
		.call(force.drag);
		nodeg.append("circle")
		.attr("r", 1)
		.attr("class", "node")
		.style("stroke-width", 0)
		.style("stroke", "#808080");
	nodeg.append("text")
		.attr("x", -5)
		.attr("y", -5)
		.attr("class", "node")
		.text(function(d) {return d.label})
		.style("display", "none");
      
  	node.exit().transition().duration(300).attr("r",1).remove();
  	link.enter().insert("line", ".node")
    	.attr("class", "link");
      
	link.exit().remove();
  
  	arrowhead.enter().insert("circle", ".node")
		.attr("class", "arrowhead")
		.attr("r",2)
		.style("opacity", function() {return 0;});
    
    arrowhead.exit().remove();
  	force.start();
	//Apparently you have to delay the resizing to keep D3 from holding the elements that are supposed to be .removed()  
	resize(currentSizing);
}

function getBetweenness() {
	updateText("Betweenness");
}

function updateForce() {
	force.stop();
	
	var newGravity = document.getElementById('gravitySlider').value;
	document.getElementById('gravityInput').value = newGravity;
	
	force.gravity(newGravity);
	force.start();
}

function randomGraph(nodeNumber, linkChance) {
	newGraphObj = {nodes: [], links: []};
	var x=0;
	while (x < nodeNumber) {
		var randomLat = Math.random();
		var randomLong = Math.random();
		var newNodeObj = {label: "Node"+x, id: x, lat: randomLat, long: randomLong}
		newGraphObj.nodes.push(newNodeObj);
		var y=0;
		while (y < nodeNumber) {
			if (y != x && Math.random() < linkChance) {
				var randomEdgeWeight = Math.random();
				newLinkObj = {source: x, target: y, weight: randomEdgeWeight, cost: randomEdgeWeight}
				newGraphObj.links.push(newLinkObj);
			}
			y++;
		}
		x++;
	}
	
	d3.select("#networkViz").remove();
	initializeGraph(newGraphObj);
}

function plotLayout() {
  force.stop();
  minX = d3.min(nodes, function(d) {return parseFloat(d["long"])});
  maxX = d3.max(nodes, function(d) {return parseFloat(d["long"])});
  minY = d3.min(nodes, function(d) {return parseFloat(d["lat"])});
  maxY = d3.max(nodes, function(d) {return parseFloat(d["lat"])});
  heightRamp=d3.scale.linear().domain([minY,maxY]).range([550,50]).clamp(true);
  widthRamp=d3.scale.linear().domain([minX,maxX]).range([50,450]).clamp(true);
  
  d3.selectAll("g.node").transition().duration(1000).attr("transform",function(d) {return "translate(" + widthRamp(parseFloat(d["long"])) + "," + heightRamp(parseFloat(d["lat"])) + ")"})
  for (x in nodes) {
    nodes[x].x = widthRamp(parseFloat(nodes[x].long));
    nodes[x].px = widthRamp(parseFloat(nodes[x].long));
    nodes[x].y = heightRamp(parseFloat(nodes[x].lat));
    nodes[x].py = heightRamp(parseFloat(nodes[x].lat));
  }
  
  link.transition().duration(1000).attr("x1", function(d) { return widthRamp(d.source.long); })
      .attr("y1", function(d) { return heightRamp(d.source.lat); })
      .attr("x2", function(d) { return widthRamp(d.target.long); })
      .attr("y2", function(d) { return heightRamp(d.target.lat); });
    arrowhead.transition().duration(1000)
    .attr("cx", function(d) {return ((d.target.x * .9) + (d.source.x * .1))})
    .attr("cy", function(d) {return ((d.target.y * .9) + (d.source.y * .1))})
}


function resize(byValue) {
  currentSizing = byValue;
  var minSize = d3.min(nodes, function(d) {return parseFloat(d["weight"])});
  var maxSize = d3.max(nodes, function(d) {return parseFloat(d["weight"])});
  var minWeight = d3.min(links, function(d) {return parseFloat(d["cost"])});
  var maxWeight = d3.max(links, function(d) {return parseFloat(d["cost"])});
  var sizingRamp = d3.scale.linear().domain([minSize,maxSize]).range([1,10]).clamp(true);
  var edgeRamp = d3.scale.linear().domain([maxWeight,minWeight]).range([.5,3]).clamp(true);
  
  switch(byValue)
  {
    case "nothing":
      d3.selectAll("circle.node").attr("r", 5)
      
      d3.selectAll("image.node").attr("x", -2.5)
      .attr("y", -2.5)
      .attr("width", 5)
      .attr("height", 5);
    break;
    case "degree":
      d3.selectAll("circle.node").attr("r", function(d) {return sizingRamp(d["weight"])})
      
      d3.selectAll("image.node").attr("x", function(d) { return -((sizingRamp(d["weight"]))/2)})
      .attr("y", function(d) { return -((sizingRamp(d["weight"]))/2)})
      .attr("width", function(d) { return (sizingRamp(d["weight"]))})
      .attr("height", function(d) { return (sizingRamp(d["weight"]))});
    break;
    }
    
    d3.selectAll("line.link").style("stroke-width", function(d) {return edgeRamp(d["cost"])})
}

const INF = 2100000000;
function dijkstra(point, road_to, link_list, total_node_num) {
    // initialization
    var start_vertex = point.start;
	var end_vertex = point.end;
	if (start_vertex == end_vertex) return { nodes: {}, paths: {}, total_cost: 0 };

    var d = [];             // the shortest distance to every node
    var previous = [];

    for (var i = 0; i < total_node_num; i++) {
        d.push(INF);
        previous.push("UNDEFINED");
    }

    var S = [];             // nodes already in shortest path
    var Q = [];             // nodes not in shortest path
    S.push(start_vertex);
    for (var i = 0; i < total_node_num; i++) {
        if (road_to[start_vertex][i])
            d[i] = road_to[start_vertex][i];
        if (i != start_vertex)
            Q.push(i);
    }
    d[start_vertex] = 0;

    // main algorithm
    var cur_vertex = start_vertex;
    while (Q.length && cur_vertex != end_vertex) {
        // find min distance
        var d_min = INF;
        for (var i = 0; i < Q.length; i++) {
            var vertex = Q[i];
            if (d[vertex] <= d_min) {
                d_min = d[vertex];
                cur_vertex = vertex;
            }
        }

        // add current node to S, erase current node from Q
        S.push(cur_vertex);
        Q.splice(Q.indexOf(cur_vertex), 1);

        // update distance
        for (var i = 0; i < Q.length; i++) {
            var vertex = Q[i];
            if (d[vertex] > d[cur_vertex] + road_to[cur_vertex][vertex]) {
                d[vertex] = d[cur_vertex] + road_to[cur_vertex][vertex];
                previous[vertex] = cur_vertex;
            }
        }
    }

    var node_result = [];
	var edge_result = [];
	var total_cost = 0;

    // no path
    if (d[end_vertex] == INF) {
		node_result[0] = [];
		edge_result[0] = [];
        node_result[0].push("Path not found");
        edge_result[0].push("Path not found");
        return { nodes: node_result, paths: edge_result, total_cost: INF};
    }

	node_result.push(cur_vertex);
    while (true) {
        if (previous[cur_vertex] == "UNDEFINED") break;
		node_result.push(previous[cur_vertex]);
		edge_result.push(link_list[cur_vertex][previous[cur_vertex]]);
		total_cost += links[link_list[cur_vertex][previous[cur_vertex]]].cost;
        cur_vertex = previous[cur_vertex];
    }
    node_result.push(start_vertex);
	edge_result.push(link_list[start_vertex][cur_vertex]);
	total_cost += links[link_list[start_vertex][cur_vertex]].cost;

    return { nodes: node_result, paths: edge_result, total_cost: total_cost };
}

// find the shortest path or centrality
function findPath(sourceID, targetID, centrality_flag) {
	var total_node_num = nodes.length;

    // init road_to and edge_list
    var road_to = new Array(nodes.length);        // distance between two nodes
    var edge_list = new Array(links.length);      // edge id between two nodes
    for (var i = 0; i < total_node_num; i++) {
        road_to[i] = new Array(total_node_num);
        edge_list[i] = new Array(links.length);

        for (var j = 0; j < total_node_num; j++)
            road_to[i][j] = INF;
        road_to[i][i] = 0;
    }

    for (var index in links) {
		var link = links[index];
        var source_id = link.source.id;
        var target_id = link.target.id;
        var cost = link.cost;

        road_to[source_id][target_id] = cost;
        road_to[target_id][source_id] = cost;

        edge_list[source_id][target_id] = link.id;
        edge_list[target_id][source_id] = link.id;
    }

	// get the shortest path between two nodes
	if (!centrality_flag)
		return dijkstra({start: sourceID, end: targetID}, road_to, edge_list, total_node_num);
	

	// get centrality (closeness and betweenness)
	var graphStats = {};
	for (var i in nodes) {
		graphStats[nodes[i].id] = {};
		graphStats[nodes[i].id]["Closeness"] = 0;
		graphStats[nodes[i].id]["Betweenness"] = 0;
		graphStats[nodes[i].id]["Total Connectivity"] = 0;
	}

	for (var i in nodes) {
		var sourceID = nodes[i].id;
		var connected_node_num = 0;
		var total_connected_distance = 0;

		// get all shortest path cost from source node
		for (var j in nodes) {
			var targetID = nodes[j].id;
			var result_obj = dijkstra({start: sourceID, end: targetID}, road_to, edge_list, total_node_num);

			// for closeness
			var cost = result_obj.total_cost;
			if (cost != INF) {
				connected_node_num++;
				total_connected_distance += cost;
			}

			// for betweenness
			var node_ids = result_obj.nodes;
			if (node_ids[0] != "Path not found") {
				for (var index in node_ids) {
					var node_id = node_ids[index]
					if (node_id == sourceID || node_id == targetID) continue;

					graphStats[node_id]["Betweenness"] += 1;
				}
			}
		}

		// calculate closeness
		graphStats[sourceID]["Total Connectivity"] = connected_node_num;
		if(connected_node_num == 0)
			graphStats[sourceID]["Closeness"] = 0;        
		else
			graphStats[sourceID]["Closeness"] = total_connected_distance / connected_node_num;
	}

	return graphStats;
}

function selectPath() {
	d3.selectAll("g.node").on("click",setSource).style("cursor", "pointer")
	d3.select("#definitionbox").html("Select a node to compute a path from");
}
function setSource(d) {
	sourceNode = d.id;
	d3.selectAll("g.node").on("click",setTarget);
	d3.select("#definitionbox").html(d.id + "selected - select a node to compute the path to");
}
function setTarget(d) {
	var computedPathArray = findPath(sourceNode, d.id);

	if (computedPathArray.nodes[0] == "Path not found") {
		d3.select("#definitionbox").html("No path");
		d3.selectAll("circle.node").transition().duration(300).style("fill", function(p) {return [d.id,sourceNode].indexOf(p.id) > -1 ? "brown" : "black"});
		d3.selectAll("line.link").transition().duration(300).style("stroke","black");
	}
	else {
		computedPathArray.paths.reverse();
		computedPathArray.nodes.reverse();
		d3.select("#definitionbox").html("<span style='color:brown;'>Path from " + sourceNode + " to " + d.id + ". Total cost is " + computedPathArray.total_cost + "</span>");
		d3.selectAll("circle.node").transition().delay(function(d) {return computedPathArray.nodes.indexOf("" + d.id) > -1 ? (computedPathArray.nodes.indexOf("" + d.id) * 500) + 500 : 0}).duration(300).style("fill", function(d) {return computedPathArray.nodes.indexOf(d.id) > -1 ? "brown" : "#FA8806"});
		d3.selectAll("line.link").transition().delay(function(d) {return computedPathArray.paths.indexOf(d.id) > -1 ? (computedPathArray.paths.indexOf(d.id) * 500) + 500 : 0}).duration(300).style("stroke", function(d) {return computedPathArray.paths.indexOf(d.id) > -1 ? "brown" : "#999"});
	}
	d3.selectAll("g.node").on("click", null).style("cursor","auto");
	sourceNode = "";
}

function sizeByStats(statname) {
	var minStat = 9999;
	var maxStat = 0;
    for (x in nodes) {
		if (graphStats[nodes[x].id]["Total Connectivity"] != 0) {
			minStat = Math.min(minStat, graphStats[nodes[x].id][statname]);
			maxStat = Math.max(maxStat, graphStats[nodes[x].id][statname]);
		}
    }
    
    d3.select("#definitionbox").html("Nodes are now sized by " + statname);
	var sizeRamp = d3.scale.linear().domain([minStat,maxStat]).range([2,10]).clamp(true);
	d3.selectAll("circle.node").transition().duration(300).attr("r", function(d,i) {return graphStats[nodes[i].id][statname] > 0 ? sizeRamp(graphStats[nodes[i].id][statname]) : 1});
	d3.selectAll("image.node").transition().duration(300)
	.attr("height", function(d,i) {return graphStats[nodes[i].id]["Total Connectivity"] > 0 ? sizeRamp(graphStats[nodes[i].id][statname]) : 1})
	.attr("width", function(d,i) {return graphStats[nodes[i].id]["Total Connectivity"] > 0 ? sizeRamp(graphStats[nodes[i].id][statname]) : 1})
	.attr("x", function(d,i) {return graphStats[nodes[i].id]["Total Connectivity"] > 0 ? -(sizeRamp(graphStats[nodes[i].id][statname]) / 2) : -.5})
	.attr("y", function(d,i) {return graphStats[nodes[i].id]["Total Connectivity"] > 0 ? -(sizeRamp(graphStats[nodes[i].id][statname]) / 2) : -.5});
}

function calculateCentrality() {
	d3.select("#definitionbox").html("Calculating paths...");
	graphStats = findPath(0, 0, true);
	sizeByStats("Closeness");   
}

</script>